JXJ translates XML documents into JSON documents and vice versa. It is configured via an XML file of its own.
For why we've gone to this effort, and for why the control document is XML (and not JSON or otherwise), see the 
purpose section of the architecture document.

The translation is separated at a high level into the two directions. This is to simplify the specification (at the
expense of long-windedness and typo succeptibility), by not introducing a new abstraction which risks being fragile
to unanticipated edge-cases. But more importantly, it allows the directions to be decoupled. JXJ is only intended to
take the laborious simple cases out of the translation process, complex transformations are to happen in code. This
is no XSLT, by design, code is best written in code. This means that the translation in each direction may differ
slightly or substantially, according to the surrounding code, so a ridged coupling would be brittle.

In line with this "bundle of stuff" approach, multiple templates can be specified in a single control file.

JXJ uses XPath and JPath to specify paths to incoming data and XTmpl and JTmpl to write a template for outgoing data.
At the moment, error checking in the control file is rudementary, but will improve. For an example control file, see 
collectionobject.jxj in src/main/resources org.collectionspace.chain.storage.services. Each of the two directions
has a map part (maps a path in the incoming do to a key) and a template part (maps those keys to the outgoing document).

For the syntax of XPath see XPath docs on the web, for JPath, XTmpl, JTmpl, see the relevant package in these docs.

InvalidJXJException -- something went wrong
JXJFile -- a control file which can define a number of transformers
JXJTransformer -- a maned transformer from a control file: can actually do the transform.
